{
    "sourceFile": "src/components/PieGraph/PieGraph.jsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1692908639678,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1692909688119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,10 @@\n import React, { useRef, useEffect, useCallback } from \"react\";\r\n import { createColorPalette } from \"../../utils/color\";\r\n import { createDomain, parseTooltipText } from \"../../utils/help\";\r\n import * as d3 from \"d3\";\r\n+import PieGraphPanel from \"./PieGraphPanel\";\r\n+import './PieGraph.scss';\r\n \r\n const PieGraph = ({\r\n   data,\r\n   width,\r\n@@ -211,10 +213,13 @@\n     }\r\n   }, [svgRef, createPieGraph]);\r\n \r\n   return (\r\n-    <div style={{ margin: \"2em\" }}>\r\n-      <svg ref={svgRef} width={width} height={height} />\r\n+    <div style={{ margin: \"2em\" }} className=\"pie-graph-wrapper\">\r\n+      <PieGraphPanel />\r\n+      <div className=\"pie-graph-right\">\r\n+        <svg ref={svgRef} width={width} height={height} />\r\n+      </div>\r\n     </div>\r\n   );\r\n };\r\n \r\n"
                },
                {
                    "date": 1692909709199,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,255 @@\n+import React, { useRef, useEffect, useCallback } from \"react\";\r\n+import { createColorPalette } from \"../../utils/color\";\r\n+import { createDomain, parseTooltipText } from \"../../utils/help\";\r\n+import * as d3 from \"d3\";\r\n+import PieGraphPanel from \"./PieGraphPanel\";\r\n+import './PieGraph.scss';\r\n+\r\n+const PieGraph = ({\r\n+  data,\r\n+  width,\r\n+  height,\r\n+  dataKey,\r\n+  value,\r\n+  colorPalette,\r\n+  colorType,\r\n+  margin,\r\n+  style,\r\n+  text,\r\n+  arc,\r\n+  tooltip,\r\n+  donut\r\n+}) => {\r\n+  const svgRef = useRef(null);\r\n+\r\n+  const drawSvg = useCallback(\r\n+    (div) => {\r\n+      const svg = d3\r\n+        .select(div)\r\n+        .append(\"g\")\r\n+        .attr(\"transform\", `translate(${width / 2},${height / 2})`);\r\n+      return svg;\r\n+    },\r\n+    [height, width]\r\n+  );\r\n+\r\n+  const handleUniqDataLen = useCallback(() => {\r\n+    const uniqueArr = [...new Set(data.map((el) => el[dataKey]))];\r\n+    return uniqueArr.length;\r\n+  }, [data, dataKey]);\r\n+\r\n+  const handleScale = useCallback(() => {\r\n+    const len = handleUniqDataLen();\r\n+    const paletteRange =\r\n+      colorPalette.length > 0\r\n+        ? colorPalette\r\n+        : createColorPalette(colorType, len);\r\n+    const ordScale = d3\r\n+      .scaleOrdinal()\r\n+      .domain(createDomain(data, dataKey))\r\n+      .range(paletteRange);\r\n+    return ordScale;\r\n+  }, [data, dataKey, handleUniqDataLen, colorPalette, colorType]);\r\n+\r\n+  const createPie = useCallback(() => {\r\n+    const pie = d3.pie().value((d) => d[value]);\r\n+    return pie(data);\r\n+  }, [data, value]);\r\n+\r\n+  const handleRadius = useCallback(() => {\r\n+    if (margin) {\r\n+      return Math.min(width, height) / 2 - margin;\r\n+    }\r\n+    return Math.min(width, height) / 2;\r\n+  }, [width, height, margin]);\r\n+\r\n+  const handleConerRadius = useCallback(() => {\r\n+    const outerRadius = height / 2 - 30;\r\n+    const innerRadius = outerRadius / 3;\r\n+    const limitRange = (outerRadius - innerRadius) / 2;\r\n+\r\n+    if (arc.cornerRadius >= limitRange) return limitRange;\r\n+    return arc.cornerRadius;\r\n+  }, [height, arc]);\r\n+\r\n+  const handleText = useCallback(\r\n+    (svg, data, arcGenerator, outerArc, radius) => {\r\n+      svg\r\n+        .selectAll(\"arc\")\r\n+        .data(data)\r\n+        .enter()\r\n+        .append(\"text\")\r\n+        .attr(\"class\", \"arcText\")\r\n+        .text((d) => d.data[dataKey])\r\n+        .attr(\"transform\", function (d) {\r\n+          if (text.location === \"outside\") {\r\n+            const pos = outerArc.centroid(d);\r\n+            const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;\r\n+            pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);\r\n+            return \"translate(\" + pos + \")\";\r\n+          }\r\n+          return `translate(${arcGenerator.centroid(d)})`;\r\n+        })\r\n+        .style(\"text-anchor\", function (d) {\r\n+          if (text.location === \"outside\") {\r\n+            const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;\r\n+            return midangle < Math.PI ? \"start\" : \"end\";\r\n+          }\r\n+          return text.textAnchor;\r\n+        });\r\n+    },\r\n+    [dataKey, text]\r\n+  );\r\n+\r\n+  const createTooltip = useCallback(() => {\r\n+    const tooltipDiv = d3\r\n+      .select(\".App\")\r\n+      .append(\"div\")\r\n+      .attr(\"class\", \"tooltip\")\r\n+      .style(\"position\", \"absolute\")\r\n+      .style(\"opacity\", 0);\r\n+    return tooltipDiv;\r\n+  }, []);\r\n+\r\n+  const handleInnerRadius = useCallback(\r\n+    (radius) => {\r\n+      if (donut.show) {\r\n+        return radius < donut.innerRadius ? radius : donut.innerRadius;\r\n+      }\r\n+      return 0;\r\n+    },\r\n+    [donut]\r\n+  );\r\n+\r\n+  const handleTextLine = useCallback(\r\n+    (svg, data, arcGenerator, outerArc, radius) => {\r\n+      svg\r\n+        .selectAll(\"allPolylines\")\r\n+        .data(data)\r\n+        .enter()\r\n+        .append(\"polyline\")\r\n+        .attr(\"class\", \"textLine\")\r\n+        .style(\"fill\", \"none\")\r\n+        .attr(\"points\", function (d) {\r\n+          const posA = arcGenerator.centroid(d); // line insertion in the slice\r\n+          const posB = outerArc.centroid(d); // line break: we use the other arc generator that has been built only for that\r\n+          const posC = outerArc.centroid(d); // Label position = almost the same as posB\r\n+          const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2; // we need the angle to see if the X position will be at the extreme right or extreme left\r\n+          posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left\r\n+          return [posA, posB, posC];\r\n+        });\r\n+    },\r\n+    []\r\n+  );\r\n+\r\n+  const createPieGraph = useCallback(\r\n+    (div) => {\r\n+      const svg = drawSvg(div);\r\n+      const pie_data = createPie();\r\n+      const color = handleScale();\r\n+      const radius = handleRadius();\r\n+      const arcGenerator = d3\r\n+        .arc()\r\n+        .innerRadius(handleInnerRadius(radius)) // range = 0 <= radius\r\n+        .outerRadius(radius)\r\n+        .cornerRadius(handleConerRadius())\r\n+        .padAngle(arc.padAngle);\r\n+      const outerArc = d3\r\n+        .arc()\r\n+        .innerRadius(radius * 0.9)\r\n+        .outerRadius(radius * 0.9);\r\n+\r\n+      const Tooltip = createTooltip();\r\n+\r\n+      // create arc and fill in the color by value\r\n+      svg\r\n+        .selectAll(\".arc\")\r\n+        .data(pie_data)\r\n+        .enter()\r\n+        .append(\"path\")\r\n+        .attr(\"class\", \"arc\")\r\n+        .attr(\"d\", arcGenerator)\r\n+        .attr(\"fill\", (d) => color(d.data[dataKey]))\r\n+        .on(\"mouseover\", function (event, d) {\r\n+          tooltip.show &&\r\n+            Tooltip.transition()\r\n+              .duration(200)\r\n+              .style(\"opacity\", 1)\r\n+              .style(\"left\", event.pageX + 20 + \"px\")\r\n+              .style(\"top\", event.pageY - 20 + \"px\")\r\n+              .text(parseTooltipText(tooltip.text, d.data));\r\n+        })\r\n+        .on(\"mouseout\", function (event, d) {\r\n+          tooltip.show &&\r\n+            Tooltip.transition().duration(500).style(\"opacity\", 0);\r\n+        });\r\n+\r\n+      // text line\r\n+      text.showLine &&\r\n+        handleTextLine(svg, pie_data, arcGenerator, outerArc, radius);\r\n+      // text\r\n+      text.show && handleText(svg, pie_data, arcGenerator, outerArc, radius);\r\n+    },\r\n+    [\r\n+      handleTextLine,\r\n+      handleInnerRadius,\r\n+      dataKey,\r\n+      tooltip,\r\n+      createTooltip,\r\n+      drawSvg,\r\n+      createPie,\r\n+      handleScale,\r\n+      handleRadius,\r\n+      text,\r\n+      arc,\r\n+      handleConerRadius,\r\n+      handleText\r\n+    ]\r\n+  );\r\n+\r\n+  useEffect(() => {\r\n+    if (svgRef.current) {\r\n+      createPieGraph(svgRef.current);\r\n+    }\r\n+  }, [svgRef, createPieGraph]);\r\n+\r\n+  return (\r\n+    <div style={{ margin: \"2em\" }} className=\"pie-graph-wrapper\">\r\n+      <PieGraphPanel />\r\n+      <div className=\"pie-graph-right\">\r\n+        <svg ref={svgRef} width={width} height={height} />\r\n+      </div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+PieGraph.defaultProps = {\r\n+  data: [],\r\n+  width: 300,\r\n+  height: 300,\r\n+  dataKey: \"\",\r\n+  value: \"\",\r\n+  colorPalette: [],\r\n+  colorType: \"Color-1\",\r\n+  margin: 0,\r\n+  text: {\r\n+    show: false,\r\n+    textAnchor: \"middle\",\r\n+    location: \"inside\",\r\n+    showLine: false\r\n+  },\r\n+  arc: {\r\n+    padAngle: 0,\r\n+    cornerRadius: 0\r\n+  },\r\n+  tooltip: {\r\n+    show: false,\r\n+    text: \"\"\r\n+  },\r\n+  donut: {\r\n+    show: false,\r\n+    innerRadius: 0\r\n+  }\r\n+};\r\n+\r\n+export default PieGraph;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1692909965503,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,255 @@\n+import React, { useRef, useEffect, useCallback } from \"react\";\r\n+import { createColorPalette } from \"../../utils/color\";\r\n+import { createDomain, parseTooltipText } from \"../../utils/help\";\r\n+import * as d3 from \"d3\";\r\n+import PieGraphPanel from \"./PieGraphPanel\";\r\n+import './PieGraph.scss';\r\n+\r\n+const PieGraph = ({\r\n+  data,\r\n+  width,\r\n+  height,\r\n+  dataKey,\r\n+  value,\r\n+  colorPalette,\r\n+  colorType,\r\n+  margin,\r\n+  style,\r\n+  text,\r\n+  arc,\r\n+  tooltip,\r\n+  donut\r\n+}) => {\r\n+  const svgRef = useRef(null);\r\n+\r\n+  const drawSvg = useCallback(\r\n+    (div) => {\r\n+      const svg = d3\r\n+        .select(div)\r\n+        .append(\"g\")\r\n+        .attr(\"transform\", `translate(${width / 2},${height / 2})`);\r\n+      return svg;\r\n+    },\r\n+    [height, width]\r\n+  );\r\n+\r\n+  const handleUniqDataLen = useCallback(() => {\r\n+    const uniqueArr = [...new Set(data.map((el) => el[dataKey]))];\r\n+    return uniqueArr.length;\r\n+  }, [data, dataKey]);\r\n+\r\n+  const handleScale = useCallback(() => {\r\n+    const len = handleUniqDataLen();\r\n+    const paletteRange =\r\n+      colorPalette.length > 0\r\n+        ? colorPalette\r\n+        : createColorPalette(colorType, len);\r\n+    const ordScale = d3\r\n+      .scaleOrdinal()\r\n+      .domain(createDomain(data, dataKey))\r\n+      .range(paletteRange);\r\n+    return ordScale;\r\n+  }, [data, dataKey, handleUniqDataLen, colorPalette, colorType]);\r\n+\r\n+  const createPie = useCallback(() => {\r\n+    const pie = d3.pie().value((d) => d[value]);\r\n+    return pie(data);\r\n+  }, [data, value]);\r\n+\r\n+  const handleRadius = useCallback(() => {\r\n+    if (margin) {\r\n+      return Math.min(width, height) / 2 - margin;\r\n+    }\r\n+    return Math.min(width, height) / 2;\r\n+  }, [width, height, margin]);\r\n+\r\n+  const handleConerRadius = useCallback(() => {\r\n+    const outerRadius = height / 2 - 30;\r\n+    const innerRadius = outerRadius / 3;\r\n+    const limitRange = (outerRadius - innerRadius) / 2;\r\n+\r\n+    if (arc.cornerRadius >= limitRange) return limitRange;\r\n+    return arc.cornerRadius;\r\n+  }, [height, arc]);\r\n+\r\n+  const handleText = useCallback(\r\n+    (svg, data, arcGenerator, outerArc, radius) => {\r\n+      svg\r\n+        .selectAll(\"arc\")\r\n+        .data(data)\r\n+        .enter()\r\n+        .append(\"text\")\r\n+        .attr(\"class\", \"arcText\")\r\n+        .text((d) => d.data[dataKey])\r\n+        .attr(\"transform\", function (d) {\r\n+          if (text.location === \"outside\") {\r\n+            const pos = outerArc.centroid(d);\r\n+            const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;\r\n+            pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);\r\n+            return \"translate(\" + pos + \")\";\r\n+          }\r\n+          return `translate(${arcGenerator.centroid(d)})`;\r\n+        })\r\n+        .style(\"text-anchor\", function (d) {\r\n+          if (text.location === \"outside\") {\r\n+            const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;\r\n+            return midangle < Math.PI ? \"start\" : \"end\";\r\n+          }\r\n+          return text.textAnchor;\r\n+        });\r\n+    },\r\n+    [dataKey, text]\r\n+  );\r\n+\r\n+  const createTooltip = useCallback(() => {\r\n+    const tooltipDiv = d3\r\n+      .select(\".App\")\r\n+      .append(\"div\")\r\n+      .attr(\"class\", \"tooltip\")\r\n+      .style(\"position\", \"absolute\")\r\n+      .style(\"opacity\", 0);\r\n+    return tooltipDiv;\r\n+  }, []);\r\n+\r\n+  const handleInnerRadius = useCallback(\r\n+    (radius) => {\r\n+      if (donut.show) {\r\n+        return radius < donut.innerRadius ? radius : donut.innerRadius;\r\n+      }\r\n+      return 0;\r\n+    },\r\n+    [donut]\r\n+  );\r\n+\r\n+  const handleTextLine = useCallback(\r\n+    (svg, data, arcGenerator, outerArc, radius) => {\r\n+      svg\r\n+        .selectAll(\"allPolylines\")\r\n+        .data(data)\r\n+        .enter()\r\n+        .append(\"polyline\")\r\n+        .attr(\"class\", \"textLine\")\r\n+        .style(\"fill\", \"none\")\r\n+        .attr(\"points\", function (d) {\r\n+          const posA = arcGenerator.centroid(d); // line insertion in the slice\r\n+          const posB = outerArc.centroid(d); // line break: we use the other arc generator that has been built only for that\r\n+          const posC = outerArc.centroid(d); // Label position = almost the same as posB\r\n+          const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2; // we need the angle to see if the X position will be at the extreme right or extreme left\r\n+          posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left\r\n+          return [posA, posB, posC];\r\n+        });\r\n+    },\r\n+    []\r\n+  );\r\n+\r\n+  const createPieGraph = useCallback(\r\n+    (div) => {\r\n+      const svg = drawSvg(div);\r\n+      const pie_data = createPie();\r\n+      const color = handleScale();\r\n+      const radius = handleRadius();\r\n+      const arcGenerator = d3\r\n+        .arc()\r\n+        .innerRadius(handleInnerRadius(radius)) // range = 0 <= radius\r\n+        .outerRadius(radius)\r\n+        .cornerRadius(handleConerRadius())\r\n+        .padAngle(arc.padAngle);\r\n+      const outerArc = d3\r\n+        .arc()\r\n+        .innerRadius(radius * 0.9)\r\n+        .outerRadius(radius * 0.9);\r\n+\r\n+      const Tooltip = createTooltip();\r\n+\r\n+      // create arc and fill in the color by value\r\n+      svg\r\n+        .selectAll(\".arc\")\r\n+        .data(pie_data)\r\n+        .enter()\r\n+        .append(\"path\")\r\n+        .attr(\"class\", \"arc\")\r\n+        .attr(\"d\", arcGenerator)\r\n+        .attr(\"fill\", (d) => color(d.data[dataKey]))\r\n+        .on(\"mouseover\", function (event, d) {\r\n+          tooltip.show &&\r\n+            Tooltip.transition()\r\n+              .duration(200)\r\n+              .style(\"opacity\", 1)\r\n+              .style(\"left\", event.pageX + 20 + \"px\")\r\n+              .style(\"top\", event.pageY - 20 + \"px\")\r\n+              .text(parseTooltipText(tooltip.text, d.data));\r\n+        })\r\n+        .on(\"mouseout\", function (event, d) {\r\n+          tooltip.show &&\r\n+            Tooltip.transition().duration(500).style(\"opacity\", 0);\r\n+        });\r\n+\r\n+      // text line\r\n+      text.showLine &&\r\n+        handleTextLine(svg, pie_data, arcGenerator, outerArc, radius);\r\n+      // text\r\n+      text.show && handleText(svg, pie_data, arcGenerator, outerArc, radius);\r\n+    },\r\n+    [\r\n+      handleTextLine,\r\n+      handleInnerRadius,\r\n+      dataKey,\r\n+      tooltip,\r\n+      createTooltip,\r\n+      drawSvg,\r\n+      createPie,\r\n+      handleScale,\r\n+      handleRadius,\r\n+      text,\r\n+      arc,\r\n+      handleConerRadius,\r\n+      handleText\r\n+    ]\r\n+  );\r\n+\r\n+  useEffect(() => {\r\n+    if (svgRef.current) {\r\n+      createPieGraph(svgRef.current);\r\n+    }\r\n+  }, [svgRef, createPieGraph]);\r\n+\r\n+  return (\r\n+    <div style={{ margin: \"2em\" }} className=\"pie-graph-wrapper\">\r\n+      <PieGraphPanel />\r\n+      <div className=\"pie-graph-right\">\r\n+        <svg ref={svgRef} width={width} height={height} />\r\n+      </div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+PieGraph.defaultProps = {\r\n+  data: [],\r\n+  width: 300,\r\n+  height: 300,\r\n+  dataKey: \"\",\r\n+  value: \"\",\r\n+  colorPalette: [],\r\n+  colorType: \"Color-1\",\r\n+  margin: 0,\r\n+  text: {\r\n+    show: false,\r\n+    textAnchor: \"middle\",\r\n+    location: \"inside\",\r\n+    showLine: false\r\n+  },\r\n+  arc: {\r\n+    padAngle: 0,\r\n+    cornerRadius: 0\r\n+  },\r\n+  tooltip: {\r\n+    show: false,\r\n+    text: \"\"\r\n+  },\r\n+  donut: {\r\n+    show: false,\r\n+    innerRadius: 0\r\n+  }\r\n+};\r\n+\r\n+export default PieGraph;\n\\ No newline at end of file\n"
                }
            ],
            "date": 1692908639678,
            "name": "Commit-0",
            "content": "import React, { useRef, useEffect, useCallback } from \"react\";\r\nimport { createColorPalette } from \"../../utils/color\";\r\nimport { createDomain, parseTooltipText } from \"../../utils/help\";\r\nimport * as d3 from \"d3\";\r\n\r\nconst PieGraph = ({\r\n  data,\r\n  width,\r\n  height,\r\n  dataKey,\r\n  value,\r\n  colorPalette,\r\n  colorType,\r\n  margin,\r\n  style,\r\n  text,\r\n  arc,\r\n  tooltip,\r\n  donut\r\n}) => {\r\n  const svgRef = useRef(null);\r\n\r\n  const drawSvg = useCallback(\r\n    (div) => {\r\n      const svg = d3\r\n        .select(div)\r\n        .append(\"g\")\r\n        .attr(\"transform\", `translate(${width / 2},${height / 2})`);\r\n      return svg;\r\n    },\r\n    [height, width]\r\n  );\r\n\r\n  const handleUniqDataLen = useCallback(() => {\r\n    const uniqueArr = [...new Set(data.map((el) => el[dataKey]))];\r\n    return uniqueArr.length;\r\n  }, [data, dataKey]);\r\n\r\n  const handleScale = useCallback(() => {\r\n    const len = handleUniqDataLen();\r\n    const paletteRange =\r\n      colorPalette.length > 0\r\n        ? colorPalette\r\n        : createColorPalette(colorType, len);\r\n    const ordScale = d3\r\n      .scaleOrdinal()\r\n      .domain(createDomain(data, dataKey))\r\n      .range(paletteRange);\r\n    return ordScale;\r\n  }, [data, dataKey, handleUniqDataLen, colorPalette, colorType]);\r\n\r\n  const createPie = useCallback(() => {\r\n    const pie = d3.pie().value((d) => d[value]);\r\n    return pie(data);\r\n  }, [data, value]);\r\n\r\n  const handleRadius = useCallback(() => {\r\n    if (margin) {\r\n      return Math.min(width, height) / 2 - margin;\r\n    }\r\n    return Math.min(width, height) / 2;\r\n  }, [width, height, margin]);\r\n\r\n  const handleConerRadius = useCallback(() => {\r\n    const outerRadius = height / 2 - 30;\r\n    const innerRadius = outerRadius / 3;\r\n    const limitRange = (outerRadius - innerRadius) / 2;\r\n\r\n    if (arc.cornerRadius >= limitRange) return limitRange;\r\n    return arc.cornerRadius;\r\n  }, [height, arc]);\r\n\r\n  const handleText = useCallback(\r\n    (svg, data, arcGenerator, outerArc, radius) => {\r\n      svg\r\n        .selectAll(\"arc\")\r\n        .data(data)\r\n        .enter()\r\n        .append(\"text\")\r\n        .attr(\"class\", \"arcText\")\r\n        .text((d) => d.data[dataKey])\r\n        .attr(\"transform\", function (d) {\r\n          if (text.location === \"outside\") {\r\n            const pos = outerArc.centroid(d);\r\n            const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;\r\n            pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);\r\n            return \"translate(\" + pos + \")\";\r\n          }\r\n          return `translate(${arcGenerator.centroid(d)})`;\r\n        })\r\n        .style(\"text-anchor\", function (d) {\r\n          if (text.location === \"outside\") {\r\n            const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;\r\n            return midangle < Math.PI ? \"start\" : \"end\";\r\n          }\r\n          return text.textAnchor;\r\n        });\r\n    },\r\n    [dataKey, text]\r\n  );\r\n\r\n  const createTooltip = useCallback(() => {\r\n    const tooltipDiv = d3\r\n      .select(\".App\")\r\n      .append(\"div\")\r\n      .attr(\"class\", \"tooltip\")\r\n      .style(\"position\", \"absolute\")\r\n      .style(\"opacity\", 0);\r\n    return tooltipDiv;\r\n  }, []);\r\n\r\n  const handleInnerRadius = useCallback(\r\n    (radius) => {\r\n      if (donut.show) {\r\n        return radius < donut.innerRadius ? radius : donut.innerRadius;\r\n      }\r\n      return 0;\r\n    },\r\n    [donut]\r\n  );\r\n\r\n  const handleTextLine = useCallback(\r\n    (svg, data, arcGenerator, outerArc, radius) => {\r\n      svg\r\n        .selectAll(\"allPolylines\")\r\n        .data(data)\r\n        .enter()\r\n        .append(\"polyline\")\r\n        .attr(\"class\", \"textLine\")\r\n        .style(\"fill\", \"none\")\r\n        .attr(\"points\", function (d) {\r\n          const posA = arcGenerator.centroid(d); // line insertion in the slice\r\n          const posB = outerArc.centroid(d); // line break: we use the other arc generator that has been built only for that\r\n          const posC = outerArc.centroid(d); // Label position = almost the same as posB\r\n          const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2; // we need the angle to see if the X position will be at the extreme right or extreme left\r\n          posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left\r\n          return [posA, posB, posC];\r\n        });\r\n    },\r\n    []\r\n  );\r\n\r\n  const createPieGraph = useCallback(\r\n    (div) => {\r\n      const svg = drawSvg(div);\r\n      const pie_data = createPie();\r\n      const color = handleScale();\r\n      const radius = handleRadius();\r\n      const arcGenerator = d3\r\n        .arc()\r\n        .innerRadius(handleInnerRadius(radius)) // range = 0 <= radius\r\n        .outerRadius(radius)\r\n        .cornerRadius(handleConerRadius())\r\n        .padAngle(arc.padAngle);\r\n      const outerArc = d3\r\n        .arc()\r\n        .innerRadius(radius * 0.9)\r\n        .outerRadius(radius * 0.9);\r\n\r\n      const Tooltip = createTooltip();\r\n\r\n      // create arc and fill in the color by value\r\n      svg\r\n        .selectAll(\".arc\")\r\n        .data(pie_data)\r\n        .enter()\r\n        .append(\"path\")\r\n        .attr(\"class\", \"arc\")\r\n        .attr(\"d\", arcGenerator)\r\n        .attr(\"fill\", (d) => color(d.data[dataKey]))\r\n        .on(\"mouseover\", function (event, d) {\r\n          tooltip.show &&\r\n            Tooltip.transition()\r\n              .duration(200)\r\n              .style(\"opacity\", 1)\r\n              .style(\"left\", event.pageX + 20 + \"px\")\r\n              .style(\"top\", event.pageY - 20 + \"px\")\r\n              .text(parseTooltipText(tooltip.text, d.data));\r\n        })\r\n        .on(\"mouseout\", function (event, d) {\r\n          tooltip.show &&\r\n            Tooltip.transition().duration(500).style(\"opacity\", 0);\r\n        });\r\n\r\n      // text line\r\n      text.showLine &&\r\n        handleTextLine(svg, pie_data, arcGenerator, outerArc, radius);\r\n      // text\r\n      text.show && handleText(svg, pie_data, arcGenerator, outerArc, radius);\r\n    },\r\n    [\r\n      handleTextLine,\r\n      handleInnerRadius,\r\n      dataKey,\r\n      tooltip,\r\n      createTooltip,\r\n      drawSvg,\r\n      createPie,\r\n      handleScale,\r\n      handleRadius,\r\n      text,\r\n      arc,\r\n      handleConerRadius,\r\n      handleText\r\n    ]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (svgRef.current) {\r\n      createPieGraph(svgRef.current);\r\n    }\r\n  }, [svgRef, createPieGraph]);\r\n\r\n  return (\r\n    <div style={{ margin: \"2em\" }}>\r\n      <svg ref={svgRef} width={width} height={height} />\r\n    </div>\r\n  );\r\n};\r\n\r\nPieGraph.defaultProps = {\r\n  data: [],\r\n  width: 300,\r\n  height: 300,\r\n  dataKey: \"\",\r\n  value: \"\",\r\n  colorPalette: [],\r\n  colorType: \"Color-1\",\r\n  margin: 0,\r\n  text: {\r\n    show: false,\r\n    textAnchor: \"middle\",\r\n    location: \"inside\",\r\n    showLine: false\r\n  },\r\n  arc: {\r\n    padAngle: 0,\r\n    cornerRadius: 0\r\n  },\r\n  tooltip: {\r\n    show: false,\r\n    text: \"\"\r\n  },\r\n  donut: {\r\n    show: false,\r\n    innerRadius: 0\r\n  }\r\n};\r\n\r\nexport default PieGraph;"
        }
    ]
}